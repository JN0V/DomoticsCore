import os
import gzip
from pathlib import Path

Import("env")

# Project dir for the example (e.g., .../examples/06-CoreWithWebUIOnly)
example_dir = Path(env["PROJECT_DIR"])  # current environment project dir
# Library root: go up one level from examples/<name> to reach DomoticsCore/
lib_root = example_dir.parents[1]

src_dir = lib_root / "webui_src"
out_dir_src = lib_root / "include" / "DomoticsCore" / "Generated"
out_dir_src.mkdir(parents=True, exist_ok=True)

out_header_src = out_dir_src / "WebUIAssets.h"
out_header_libdeps = None

# Also mirror into libdeps/DomoticsCore if available for this env
libdeps_dir = Path(env.get("PROJECT_LIBDEPS_DIR", ""))
pioenv = env.get("PIOENV", "")
if libdeps_dir and pioenv:
    out_dir_libdeps = libdeps_dir / pioenv / "DomoticsCore" / "include" / "DomoticsCore" / "Generated"
    try:
        out_dir_libdeps.mkdir(parents=True, exist_ok=True)
        out_header_libdeps = out_dir_libdeps / "WebUIAssets.h"
    except Exception:
        out_header_libdeps = None

assets = [
    ("index.html", "WEBUI_HTML_GZ"),
    ("style.css", "WEBUI_CSS_GZ"),
    ("app.js", "WEBUI_JS_GZ"),
]

# Detect whether this example actually uses WebUI
def example_uses_webui() -> bool:
    src = example_dir / "src"
    if not src.exists():
        return False
    for p in src.rglob("*.*"):
        if p.suffix.lower() not in {".cpp", ".c", ".hpp", ".h", ".ino"}:
            continue
        try:
            text = p.read_text(errors="ignore")
        except Exception:
            continue
        if "DomoticsCore/Components/WebUI.h" in text:
            return True
    return False

if not example_uses_webui():
    print("Skipping WebUI asset embedding: example does not include WebUI")
    Return()

def to_c_array(data: bytes) -> str:
    # Format as comma-separated hex bytes, wrapped to reasonable line length
    hex_bytes = [f"0x{b:02x}" for b in data]
    lines = []
    line = []
    for i, hb in enumerate(hex_bytes):
        line.append(hb)
        if (i + 1) % 16 == 0:
            lines.append(", ".join(line))
            line = []
    if line:
        lines.append(", ".join(line))
    body = ",\n        ".join(lines)
    return body

header_lines = [
    "#pragma once",
    "#include <Arduino.h>",
    "",
    "// Auto-generated by scripts/embed_webui.py. DO NOT EDIT MANUALLY.",
]

for filename, sym in assets:
    path = src_dir / filename
    if not path.exists():
        raise RuntimeError(f"Missing asset: {path}")
    raw = path.read_bytes()
    gz = gzip.compress(raw, compresslevel=9)
    header_lines.append("")
    header_lines.append(f"// {filename} (gzip), original {len(raw)} bytes, gzip {len(gz)} bytes")
    header_lines.append(f"extern const uint8_t {sym}[] PROGMEM;")
    header_lines.append(f"extern const size_t {sym}_LEN;")

# Write externs header first (declarations)
# We will also write definitions alongside (in the same header for simplicity)
# Some compilers allow this as 'inline' style for constants; for clarity we emit both declarations and definitions.

# Append a separator and actual definitions
header_lines.append("")
header_lines.append("// Definitions")

for filename, sym in assets:
    path = src_dir / filename
    raw = path.read_bytes()
    gz = gzip.compress(raw, compresslevel=9)
    header_lines.append("")
    header_lines.append(f"const uint8_t {sym}[] PROGMEM = {{")
    header_lines.append(f"        {to_c_array(gz)}")
    header_lines.append("};")
    header_lines.append(f"const size_t {sym}_LEN = sizeof({sym});")

out_text = "\n".join(header_lines) + "\n"
out_header_src.write_text(out_text)
print(f"Embedded WebUI assets -> {out_header_src}")
if out_header_libdeps:
    try:
        out_header_libdeps.write_text(out_text)
        print(f"Mirrored WebUI assets -> {out_header_libdeps}")
    except Exception as e:
        print(f"Warning: could not write libdeps header: {e}")

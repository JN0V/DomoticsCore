#pragma once

/**
 * @file Wifi.h
 * @brief WiFi component for managing WiFi connectivity.
 * 
 * @example DomoticsCore-Wifi/examples/BasicWifi/src/main.cpp
 * @example DomoticsCore-Wifi/examples/WifiWithWebUI/src/main.cpp
 * 
 * @brief Declares the DomoticsCore WiFi component providing STA/AP management and async scanning.
 */

#include <Arduino.h>
#include "Wifi_HAL.h"  // Hardware Abstraction Layer for WiFi
#include "INetworkProvider.h"
#include "DomoticsCore/IComponent.h"
#include "DomoticsCore/Logger.h"
#include "DomoticsCore/Timer.h"
#include "DomoticsCore/Events.h"
#include <ArduinoJson.h>

namespace DomoticsCore {
namespace Components {

// Use HAL WiFi abstraction for multi-platform support
// All calls use HAL::WiFiHAL:: prefix for clarity

/**
 * WiFi Component Configuration
 * 
 * Behavior:
 * - If ssid is empty: Device starts in AP mode (enableAP ignored, always true)
 * - If ssid is set: Device connects to WiFi, AP enabled only if enableAP=true
 */
struct WifiConfig {
    // Station (STA) mode settings
    String ssid = "";                   // WiFi network SSID (empty = AP-only mode)
    String password = "";               // WiFi network password
    bool autoConnect = true;            // Auto-connect on boot if SSID set
    
    // Access Point (AP) mode settings
    bool enableAP = false;              // Enable AP alongside STA (ignored if no SSID)
    String apSSID = "";                 // AP SSID (auto-generated if empty)
    String apPassword = "";             // AP password (open if empty)
    
    // Advanced settings
    uint32_t reconnectInterval = 5000;  // Reconnection interval in ms
    uint32_t connectionTimeout = 15000; // Connection timeout in ms
};

/**
 * @class DomoticsCore::Components::WifiComponent
 * @brief Manages WiFi connectivity including STA/AP modes and async scanning.
 * Uses HAL abstraction for multi-platform support (ESP32, ESP8266).
 *
 * Handles connection lifecycle, reconnection strategies, and exposes helpers for enabling AP,
 * switching credentials, and collecting scan results without blocking the event loop. Can be
 * paired with a WebUI provider to expose runtime settings.
 */
/**
 * WiFi component providing network connectivity
 * 
 * Note: For WiFi-specific checks, use isSTAConnected() and isAPEnabled().
 * The INetworkProvider::isConnected() method is implemented as hasConnectivity()
 * which returns true if either STA or AP mode is active.
 */
class WifiComponent : public IComponent, public INetworkProvider {
private:
    String ssid;
    String password;
    Utils::NonBlockingDelay reconnectTimer;
    Utils::NonBlockingDelay statusTimer;
    Utils::NonBlockingDelay connectionTimer;
    
    bool shouldConnect;
    bool isConnecting;
    unsigned long connectionStartTime;
    
    // New API state
    bool wifiEnabled;
    bool apEnabled;
    String apSSID_;
    String apPassword_;
    // Non-blocking scan state
    bool scanInProgress = false;
    String lastScanSummary_;
    static const unsigned long CONNECTION_TIMEOUT = 15000; // 15 seconds
    
public:
    /**
     * Constructor
     * @param ssid Wifi network name (empty = configure later)
     * @param password Wifi password
     */
    WifiComponent(const String& ssid = "", const String& password = "") 
        : ssid(ssid), password(password), 
          reconnectTimer(5000), statusTimer(30000), connectionTimer(100),
          shouldConnect(true), isConnecting(false), connectionStartTime(0),
          wifiEnabled(true), apEnabled(false) {
        // Initialize component metadata immediately for dependency resolution
        metadata.name = "Wifi";
        metadata.version = "1.3.0";
        metadata.author = "DomoticsCore";
        metadata.description = "Wifi connectivity management component";
    }
    
    ComponentStatus begin() override {
        DLOG_I(LOG_WIFI, "Initializing...");
        
        // If no STA credentials
        if (ssid.isEmpty()) {
            // If AP was pre-enabled (e.g., by System with deviceName-based SSID), start AP-only with that SSID
            if (apEnabled && apSSID_.length() > 0) {
                DLOG_I(LOG_WIFI, "No STA credentials - starting preconfigured AP: %s", apSSID_.c_str());
                HAL::WiFiHAL::setMode(HAL::WiFiHAL::Mode::AccessPoint);
                HAL::WiFiHAL::startAP(apSSID_.c_str(), apPassword_.isEmpty() ? nullptr : apPassword_.c_str());
                DLOG_I(LOG_WIFI, "AP IP address: %s", HAL::WiFiHAL::getAPIP().c_str());
                // Reflect state in internal flags so UI initial values are correct
                wifiEnabled = false;
                setStatus(ComponentStatus::Success);
                return ComponentStatus::Success;
            }
            // Otherwise, fall back to autogenerated AP (DomoticsCore-XXXXXX)
            DLOG_I(LOG_WIFI, "No STA credentials - starting default AP mode");
            ComponentStatus status = connectToWifi();
            setStatus(status);
            return status;
        }
        
        // Normal STA connection
        HAL::WiFiHAL::setMode(HAL::WiFiHAL::Mode::Station);
        HAL::WiFiHAL::setAutoReconnect(false);
        ComponentStatus status = connectToWifi();
        setStatus(status);
        return status;
    }
    
    /**
     * Called after all components ready - connect to WiFi if credentials were set late
     */
    void afterAllComponentsReady() override {
        // If credentials were set via setConfig() but not connected yet
        if (!ssid.isEmpty() && !isSTAConnected() && wifiEnabled) {
            DLOG_I(LOG_WIFI, "Connecting to WiFi with late-configured credentials...");
            connectToWifi();
        }
    }
    
    void loop() override {
        // Skip Wifi connection logic if in AP mode (empty SSID)
        if (ssid.isEmpty()) {
            return; // AP-only mode handled; flags set in connectToWifi()
        }
        
        // Handle ongoing connection attempt
        if (isConnecting) {
            if (connectionTimer.isReady()) {
                bool connected = HAL::WiFiHAL::isConnected();
                
                if (connected) {
                    // Connection successful
                    isConnecting = false;
                    DLOG_I(LOG_WIFI, "Wifi connected successfully");
                    DLOG_I(LOG_WIFI, "IP address: %s", HAL::WiFiHAL::getLocalIP().c_str());
                    setStatus(ComponentStatus::Success);
                    // Emit event to trigger immediate WebUI update
                    emit(DomoticsCore::Events::EVENT_WIFI_STA_CONNECTED, true);
                } else if (millis() - connectionStartTime > CONNECTION_TIMEOUT) {
                    // Connection timeout
                    isConnecting = false;
                    DLOG_E(LOG_WIFI, "Wifi connection timeout - status: %d", HAL::WiFiHAL::getRawStatus());
                    setStatus(ComponentStatus::TimeoutError);
                    emit(DomoticsCore::Events::EVENT_WIFI_STA_CONNECTED, false);
                }
            }
        }
        
        // Handle reconnection attempts
        if (shouldConnect && !isConnecting && !isSTAConnected() && reconnectTimer.isReady()) {
            DLOG_I(LOG_WIFI, "Attempting Wifi reconnection...");
            startConnection();
        }
        
        // Periodic status updates
        if (statusTimer.isReady()) {
            if (isSTAConnected()) {
                DLOG_D(LOG_WIFI, "Wifi connected - IP: %s, RSSI: %d dBm", 
                      HAL::WiFiHAL::getLocalIP().c_str(), HAL::WiFiHAL::getRSSI());
            } else {
                DLOG_D(LOG_WIFI, "Wifi disconnected - status: %s", 
                      getConnectionStatusString().c_str());
            }
        }

        // Poll async scan completion without blocking
        if (scanInProgress) {
            int res = HAL::WiFiHAL::scanComplete();
            if (res == -2) {  // WIFI_SCAN_FAILED
                DLOG_W(LOG_WIFI, "Wifi async scan failed");
                lastScanSummary_ = "Scan failed";
                scanInProgress = false;
            } else if (res >= 0) {
                String summary;
                for (int i = 0; i < res && i < 10; ++i) {
                    if (i) summary += ", ";
                    summary += HAL::WiFiHAL::getScannedSSID(i) + " (" + String(HAL::WiFiHAL::getScannedRSSI(i)) + " dBm)";
                }
                lastScanSummary_ = summary;
                HAL::WiFiHAL::scanDelete();
                scanInProgress = false;
                DLOG_I(LOG_WIFI, "Async scan complete: %d networks", res);
            }
        }
    }
    
    ComponentStatus shutdown() override {
        DLOG_I(LOG_WIFI, "Wifi Shutting down component...");
        shouldConnect = false;
        HAL::WiFiHAL::disconnectAndOff();
        setStatus(ComponentStatus::Success);
        return ComponentStatus::Success;
    }
    
    
    // Wifi-specific methods
    
    /**
     * @brief Check if STA (station) mode is connected to a WiFi network
     * @return true if connected as a station to a WiFi network, false otherwise
     * 
     * This checks actual WiFi network connectivity (STA mode).
     */
    bool isSTAConnected() const {
        return HAL::WiFiHAL::isConnected();
    }
    
    /**
     * @brief Alias for isAPEnabled() for semantic clarity
     * @return true if AP mode is active, false otherwise
     */
    bool isAPConnected() const {
        return isAPEnabled();
    }
    
    /**
     * @brief Check if either STA or AP mode is active
     * @return true if STA connected OR AP enabled, false otherwise
     * 
     * Use this to check if WiFi subsystem has any connectivity.
     * For specific checks, use isSTAConnected() or isAPEnabled().
     */
    bool hasConnectivity() const {
        return isSTAConnected() || isAPEnabled();
    }
    
    // INetworkProvider interface implementation
    /**
     * @brief INetworkProvider interface: Check if network is available
     * @return true if WiFi has any connectivity (STA or AP), false otherwise
     * 
     * Note: For WiFi-specific checks, prefer isSTAConnected() or isAPEnabled().
     * This generic method returns true if WiFi subsystem has any connectivity.
     */
    bool isConnected() const override {
        return hasConnectivity();
    }
    
    String getLocalIP() const override {
        // In STA+AP mode, prioritize station IP for connectivity
        if (isSTAAPMode() && HAL::WiFiHAL::isConnected()) {
            return HAL::WiFiHAL::getLocalIP();
        }
        // In AP-only mode, return AP IP
        else if (isAPMode()) {
            return HAL::WiFiHAL::getAPIP();
        }
        // In station mode, return station IP
        return HAL::WiFiHAL::getLocalIP();
    }
    
    String getSSID() const {
        // In STA+AP mode, prioritize station SSID for connectivity
        if (isSTAAPMode() && HAL::WiFiHAL::isConnected()) {
            return HAL::WiFiHAL::getSSID();
        }
        // In AP-only mode, return AP SSID
        else if (isAPMode()) {
            return HAL::WiFiHAL::getAPSSID();
        }
        // In station mode, return station SSID
        return HAL::WiFiHAL::getSSID();
    }
    // Configured (target) SSID string (not necessarily connected)
    String getConfiguredSSID() const { return ssid; }
    
    int32_t getRSSI() const {
        return HAL::WiFiHAL::getRSSI();
    }
    
    String getMacAddress() const {
        return HAL::WiFiHAL::getMacAddress();
    }

    // Update credentials and (optionally) start reconnecting
    void setCredentials(const String& newSsid, const String& newPassword, bool reconnectNow = true) {
        ssid = newSsid;
        password = newPassword;
        if (reconnectNow) {
            shouldConnect = true;
            isConnecting = false;
            reconnectTimer.reset();
            startConnection();
        }
    }
    
    // INetworkProvider interface implementation
    String getNetworkType() const override {
        return "Wifi";
    }
    
    String getConnectionStatus() const override {
        return getConnectionStatusString();
    }
    
    String getNetworkInfo() const override {
        JsonDocument info;
        info["type"] = "Wifi";
        info["sta_connected"] = isSTAConnected();
        info["ap_enabled"] = isAPEnabled();
        
        if (isSTAConnected()) {
            info["ssid"] = getSSID();
            info["ip_address"] = getLocalIP();
            info["signal_strength"] = getRSSI();
            info["mac_address"] = getMacAddress();
        }
        
        // AP mode info
        bool apMode = isAPMode();
        info["ap_mode"] = apMode;
        if (apMode) {
            info["ap_ssid"] = HAL::WiFiHAL::getAPSSID();
            info["ap_ip"] = HAL::WiFiHAL::getAPIP();
        }
        
        String result;
        serializeJson(info, result);
        return result;
    }
    
    void disconnect() {
        shouldConnect = false;
        HAL::WiFiHAL::disconnect();
        DLOG_I(LOG_WIFI, "Wifi manually disconnected");
    }
    
    void reconnect() {
        shouldConnect = true;
        reconnectTimer.reset();
        if (!isConnecting) {
            startConnection();
        }
        DLOG_I(LOG_WIFI, "Wifi reconnection requested");
    }
    
    bool isConnectionInProgress() const {
        return isConnecting;
    }
    
    String getDetailedStatus() const {
        String status;
        
        if (isAPMode()) {
            status = "Wifi Status: AP Mode Active";
            status += "\n  AP SSID: " + HAL::WiFiHAL::getAPSSID();
            status += "\n  AP IP: " + HAL::WiFiHAL::getAPIP();
            status += "\n  Clients: " + String(HAL::WiFiHAL::getAPStationCount());
            status += "\n  MAC: " + HAL::WiFiHAL::getMacAddress();
        } else {
            status = "Wifi Status: " + getConnectionStatusString();
            if (HAL::WiFiHAL::isConnected()) {
                status += "\n  IP: " + HAL::WiFiHAL::getLocalIP();
                status += "\n  SSID: " + HAL::WiFiHAL::getSSID();
                status += "\n  RSSI: " + String(HAL::WiFiHAL::getRSSI()) + " dBm";
                status += "\n  MAC: " + HAL::WiFiHAL::getMacAddress();
            }
            if (isConnecting) {
                unsigned long elapsed = millis() - connectionStartTime;
                status += "\n  Connecting... (" + String(elapsed / 1000) + "s)";
            }
        }
        
        return status;
    }
    
    bool scanNetworks(std::vector<String>& networks) {
        int n = HAL::WiFiHAL::scanNetworks(false);
        networks.clear();
        
        if (n == -1) {
            DLOG_E(LOG_WIFI, "Wifi scan failed");
            return false;
        }
        
        DLOG_I(LOG_WIFI, "Found %d Wifi networks", n);
        for (int i = 0; i < n; i++) {
            String network = HAL::WiFiHAL::getScannedSSID(i) + " (" + String(HAL::WiFiHAL::getScannedRSSI(i)) + " dBm)";
            networks.push_back(network);
            DLOG_D(LOG_WIFI, "  %s", network.c_str());
        }
        
        return true;
    }

    // Start non-blocking scan (returns immediately)
    void startScanAsync() {
        if (scanInProgress) return;
        HAL::WiFiHAL::scanNetworks(true /* async */);
        scanInProgress = true;
        lastScanSummary_ = "Scanning...";
        DLOG_I(LOG_WIFI, "Started async WiFi scan");
    }

    String getLastScanSummary() const { return lastScanSummary_; }
    
    bool isSTAAPMode() const {
        return HAL::WiFiHAL::getMode() == HAL::WiFiHAL::Mode::StationAndAP;
    }
    
    /**
     * Check if currently in AP mode
     * @return true if in AP mode
     */
    bool isAPMode() const {
        HAL::WiFiHAL::Mode mode = HAL::WiFiHAL::getMode();
        return (mode == HAL::WiFiHAL::Mode::AccessPoint || mode == HAL::WiFiHAL::Mode::StationAndAP);
    }
    
    /**
     * Get AP mode information
     * @return JSON string with AP details
     */
    String getAPInfo() const {
        JsonDocument info;
        
        if (isAPMode()) {
            info["active"] = true;
            info["ssid"] = HAL::WiFiHAL::getAPSSID();
            info["ip"] = HAL::WiFiHAL::getAPIP();
            info["clients"] = HAL::WiFiHAL::getAPStationCount();
        } else {
            info["active"] = false;
        }
        
        String result;
        serializeJson(info, result);
        return result;
    }
    
    // Simple Wifi and AP management - hides mode complexity
    bool enableWifi(bool enable = true) {
        wifiEnabled = enable;
        return updateWifiMode();
    }
    
    bool enableAP(const String& apSSID, const String& apPassword = "", bool enable = true) {
        if (enable) {
            apSSID_ = apSSID;
            apPassword_ = apPassword;
            apEnabled = true;
        } else {
            apEnabled = false;
        }
        return updateWifiMode();
    }
    
    bool disableAP() {
        return enableAP("", "", false);
    }
    
    // Status methods that work with the new API
    bool isWifiEnabled() const { return wifiEnabled; }
    bool isAPEnabled() const { return apEnabled; }
    String getAPSSID() const { return apSSID_; }
    
    /**
     * @brief Get current WiFi configuration
     * @return Current WifiConfig (constructed from internal state)
     */
    WifiConfig getConfig() const {
        WifiConfig cfg;
        cfg.ssid = ssid;
        cfg.password = password;
        cfg.autoConnect = shouldConnect;
        cfg.enableAP = apEnabled;
        cfg.apSSID = apSSID_;
        cfg.apPassword = apPassword_;
        cfg.reconnectInterval = 5000; // Default from constructor
        cfg.connectionTimeout = CONNECTION_TIMEOUT;
        return cfg;
    }
    
    /**
     * @brief Set WiFi configuration
     * @param cfg New configuration to apply
     */
    void setConfig(const WifiConfig& cfg) {
        ssid = cfg.ssid;
        password = cfg.password;
        shouldConnect = cfg.autoConnect;
        wifiEnabled = cfg.autoConnect;  // Sync wifiEnabled with autoConnect for WebUI display
        apEnabled = cfg.enableAP;
        apSSID_ = cfg.apSSID;
        apPassword_ = cfg.apPassword;
        
        DLOG_I(LOG_WIFI, "Config updated: SSID=%s, autoConnect=%d, AP=%s (enabled=%d)", 
               ssid.c_str(), wifiEnabled, apSSID_.c_str(), apEnabled);
        
        // Note: Caller should call updateWifiMode() after setConfig() to apply changes
    }
    
    // Update Wifi mode based on enabled features
    bool updateWifiMode() {
        DLOG_I(LOG_WIFI, "Updating Wifi mode - Wifi: %s, AP: %s", 
               wifiEnabled ? "enabled" : "disabled", 
               apEnabled ? "enabled" : "disabled");
        
        if (wifiEnabled && apEnabled) {
            // Both Wifi and AP requested - use STA+AP mode
            DLOG_I(LOG_WIFI, "Enabling STA+AP mode");
            HAL::WiFiHAL::setMode(HAL::WiFiHAL::Mode::StationAndAP);
            delay(100);
            
            // Start AP
            bool apSuccess = HAL::WiFiHAL::startAP(apSSID_.c_str(), apPassword_.isEmpty() ? nullptr : apPassword_.c_str());
            
            if (apSuccess) {
                DLOG_I(LOG_WIFI, "AP started: %s (IP: %s)", apSSID_.c_str(), HAL::WiFiHAL::getAPIP().c_str());
                emit(DomoticsCore::Events::EVENT_WIFI_AP_ENABLED, true);
            }
            
            // Enable station connection attempts
            shouldConnect = true;
            reconnectTimer.reset();
            
            return apSuccess;
        } else if (wifiEnabled && !apEnabled) {
            // Only Wifi requested - use STA mode
            DLOG_I(LOG_WIFI, "Enabling station mode only");
            HAL::WiFiHAL::stopAP();
            emit(DomoticsCore::Events::EVENT_WIFI_AP_ENABLED, false);
            delay(100);
            HAL::WiFiHAL::setMode(HAL::WiFiHAL::Mode::Station);
            delay(100);
            shouldConnect = true;
            reconnectTimer.reset();
            return true;
        } else if (!wifiEnabled && apEnabled) {
            // Only AP requested - use AP mode
            DLOG_I(LOG_WIFI, "Enabling AP mode only");
            shouldConnect = false;
            isConnecting = false;
            HAL::WiFiHAL::disconnect();
            HAL::WiFiHAL::setMode(HAL::WiFiHAL::Mode::AccessPoint);
            delay(100);
            
            bool success = HAL::WiFiHAL::startAP(apSSID_.c_str(), apPassword_.isEmpty() ? nullptr : apPassword_.c_str());
            
            if (success) {
                DLOG_I(LOG_WIFI, "AP-only mode started: %s (IP: %s)", apSSID_.c_str(), HAL::WiFiHAL::getAPIP().c_str());
                emit(DomoticsCore::Events::EVENT_WIFI_AP_ENABLED, true);
            }
            
            return success;
        } else {
            // Both disabled - turn off Wifi
            DLOG_I(LOG_WIFI, "Disabling all Wifi features");
            shouldConnect = false;
            isConnecting = false;
            HAL::WiFiHAL::stopAP();
            HAL::WiFiHAL::disconnectAndOff();
            return true;
        }
    }

private:
    ComponentStatus connectToWifi() {
        if (ssid.isEmpty()) {
            DLOG_I(LOG_WIFI, "Wifi SSID not configured - starting in AP mode");
            
            // Generate AP SSID from MAC address for uniqueness
            String macAddress = HAL::WiFiHAL::getMacAddress();
            macAddress.replace(":", "");
            String apSSID = "DomoticsCore-" + macAddress.substring(6); // Last 6 chars of MAC
            
            HAL::WiFiHAL::setMode(HAL::WiFiHAL::Mode::AccessPoint);
            HAL::WiFiHAL::startAP(apSSID.c_str()); // No password for easy access
            DLOG_I(LOG_WIFI, "AP mode started: %s (open network)", apSSID.c_str());
            DLOG_I(LOG_WIFI, "AP IP address: %s", HAL::WiFiHAL::getAPIP().c_str());
            // Reflect state in internal flags so UI initial values are correct
            apEnabled = true;
            wifiEnabled = false;
            apSSID_ = apSSID;
            return ComponentStatus::Success;
        }
        
        // Start non-blocking connection
        startConnection();
        
        // Return pending status - actual result will be determined in loop()
        return ComponentStatus::Success;
    }
    
    void startConnection() {
        if (isConnecting) return; // Already connecting
        
        DLOG_I(LOG_WIFI, "Connecting to Wifi: %s", ssid.c_str());
        HAL::WiFiHAL::connect(ssid.c_str(), password.c_str());
        
        isConnecting = true;
        connectionStartTime = millis();
        connectionTimer.reset();
    }
    
    // Additional utility methods
    String getConnectionStatusString() const {
        uint8_t status = HAL::WiFiHAL::getRawStatus();
        switch (status) {
            case 0: return "Idle";            // WL_IDLE_STATUS
            case 1: return "SSID not available"; // WL_NO_SSID_AVAIL
            case 2: return "Scan completed";   // WL_SCAN_COMPLETED
            case 3: return "Connected";        // WL_CONNECTED
            case 4: return "Connection failed"; // WL_CONNECT_FAILED
            case 5: return "Connection lost";  // WL_CONNECTION_LOST
            case 6: return "Disconnected";     // WL_DISCONNECTED
            default: return "Unknown (" + String(status) + ")";
        }
    }
};


} // namespace Components
} // namespace DomoticsCore

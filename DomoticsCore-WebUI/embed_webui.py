import os
import gzip
from pathlib import Path

Import("env")

# Project dir for the example (e.g., .../examples/LEDWithWebUI)
example_dir = Path(env["PROJECT_DIR"])  # current environment project dir

# Resolve assets relative to the repository 'DomoticsCore/DomoticsCore-WebUI' folder
# Walk up from the example dir to find a 'packages' directory
packages_root = None
for parent in example_dir.parents:
    if parent.name == "DomoticsCore":
        packages_root = parent
        break

if packages_root is None:
    # Fallback: assume this script is inside the package when __file__ is available
    try:
        package_root = Path(__file__).resolve().parent
    except NameError:
        raise RuntimeError("Unable to locate 'packages' directory and __file__ is unavailable to resolve package root")
else:
    package_root = packages_root / "DomoticsCore-WebUI"

src_dir = package_root / "webui_src"
out_dir_src = package_root / "include" / "DomoticsCore" / "Generated"
out_dir_src.mkdir(parents=True, exist_ok=True)

out_header_src = out_dir_src / "WebUIAssets.h"
out_header_libdeps = None

# Also mirror into libdeps for this env (prefer DomoticsCore-WebUI package folder if present)
libdeps_dir = Path(env.get("PROJECT_LIBDEPS_DIR", ""))
pioenv = env.get("PIOENV", "")
if libdeps_dir and pioenv:
    # Try DomoticsCore-WebUI first
    candidates = [
        libdeps_dir / pioenv / "DomoticsCore-WebUI" / "include" / "DomoticsCore" / "Generated",
        libdeps_dir / pioenv / "DomoticsCore" / "include" / "DomoticsCore" / "Generated",
    ]
    out_header_libdeps = None
    for out_dir in candidates:
        try:
            out_dir.mkdir(parents=True, exist_ok=True)
            out_header_libdeps = out_dir / "WebUIAssets.h"
            break
        except Exception:
            continue

assets = [
    ("index.html", "WEBUI_HTML_GZ"),
    ("style.css", "WEBUI_CSS_GZ"),
    ("app.js", "WEBUI_JS_GZ"),
]

# Detect whether this example actually uses WebUI
def example_uses_webui() -> bool:
    src = example_dir / "src"
    if not src.exists():
        return False
    for p in src.rglob("*.*"):
        if p.suffix.lower() not in {".cpp", ".c", ".hpp", ".h", ".ino"}:
            continue
        try:
            text = p.read_text(errors="ignore")
        except Exception:
            continue
        # Support both include paths and class name usage
        if (
            "DomoticsCore/WebUI.h" in text
            or "WebUIComponent" in text
        ):
            return True
    return False

if not example_uses_webui():
    print("Skipping WebUI asset embedding: example does not include WebUI")
    Return()

def to_c_array(data: bytes) -> str:
    # Format as comma-separated hex bytes, wrapped to reasonable line length
    hex_bytes = [f"0x{b:02x}" for b in data]
    lines = []
    line = []
    for i, hb in enumerate(hex_bytes):
        line.append(hb)
        if (i + 1) % 16 == 0:
            lines.append(", ".join(line))
            line = []
    if line:
        lines.append(", ".join(line))
    body = ",\n        ".join(lines)
    return body

header_lines = [
    "#pragma once",
    "#include <Arduino.h>",
    "",
    "// Auto-generated by scripts/embed_webui.py. DO NOT EDIT MANUALLY.",
]

for filename, sym in assets:
    path = src_dir / filename
    if not path.exists():
        raise RuntimeError(f"Missing asset: {path}")
    raw = path.read_bytes()
    gz = gzip.compress(raw, compresslevel=9)
    header_lines.append("")
    header_lines.append(f"// {filename} (gzip), original {len(raw)} bytes, gzip {len(gz)} bytes")
    header_lines.append(f"extern const uint8_t {sym}[] PROGMEM;")
    header_lines.append(f"extern const size_t {sym}_LEN;")

# Write externs header first (declarations)
# We will also write definitions alongside (in the same header for simplicity)
# Some compilers allow this as 'inline' style for constants; for clarity we emit both declarations and definitions.

# Append a separator and actual definitions
header_lines.append("")
header_lines.append("// Definitions")

for filename, sym in assets:
    path = src_dir / filename
    raw = path.read_bytes()
    gz = gzip.compress(raw, compresslevel=9)
    header_lines.append("")
    header_lines.append(f"const uint8_t {sym}[] PROGMEM = {{")
    header_lines.append(f"        {to_c_array(gz)}")
    header_lines.append("};")
    header_lines.append(f"const size_t {sym}_LEN = sizeof({sym});")

out_text = "\n".join(header_lines) + "\n"
out_header_src.write_text(out_text)
print(f"Embedded WebUI assets -> {out_header_src}")
if out_header_libdeps:
    try:
        out_header_libdeps.write_text(out_text)
        print(f"Mirrored WebUI assets -> {out_header_libdeps}")
    except Exception as e:
        print(f"Warning: could not write libdeps header: {e}")
